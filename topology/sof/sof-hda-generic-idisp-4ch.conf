








SectionData."SOF_ABI" {
	bytes "0x03,0x0b,0x00"
}
SectionManifest.STR(sof_manifest) {
	data [
		SOF_ABI
	]
}
#
# Topology for SKL+ HDA Generic machine w/ iDISP codec only
#

# Include topology builder




































 
























# Include TLV library
# TLV
#
# Common TLV control ranges
#

SectionTLV."vtlv_m64s2" {
	Comment "-64dB step 2dB"

	scale {
		min "-6400"
		step "200"
		mute "1"
	}
}

SectionTLV."vtlv_m50s1" {
	Comment "-50dB step 1dB"

	scale {
		min "-5000"
		step "100"
		mute "1"
	}
}


# Include Token library

#
# SOF Tokens for differentiation.
#
# Differentiation can be done at the platform and machine level.
#
# Tokens are GUIDs

# TODO: pre-process this with UAPI headers GNU cpp.


SectionVendorTokens."sof_buffer_tokens" {
	SOF_TKN_BUF_SIZE			"100"
	SOF_TKN_BUF_CAPS			"101"
}

SectionVendorTokens."sof_dai_tokens" {
# Token retired with ABI 3.2, do not use for new capabilities
#	SOF_TKN_DAI_DMAC_CONFIG			"153"
	SOF_TKN_DAI_TYPE			"154"
	SOF_TKN_DAI_INDEX			"155"
	SOF_TKN_DAI_DIRECTION			"156"
}

SectionVendorTokens."sof_sched_tokens" {
	SOF_TKN_SCHED_PERIOD			"200"
	SOF_TKN_SCHED_PRIORITY			"201"
	SOF_TKN_SCHED_MIPS			"202"
	SOF_TKN_SCHED_CORE			"203"
	SOF_TKN_SCHED_FRAMES			"204"
	SOF_TKN_SCHED_TIME_DOMAIN		"205"
}

SectionVendorTokens."sof_volume_tokens" {
	SOF_TKN_VOLUME_RAMP_STEP_TYPE		"250"
	SOF_TKN_VOLUME_RAMP_STEP_MS		"251"
}

SectionVendorTokens."sof_src_tokens" {
	SOF_TKN_SRC_RATE_IN			"300"
	SOF_TKN_SRC_RATE_OUT			"301"
}

SectionVendorTokens."sof_pcm_tokens" {
	SOF_TKN_PCM_DMAC_CONFIG			"353"
}

SectionVendorTokens."sof_comp_tokens" {
	SOF_TKN_COMP_PERIOD_SINK_COUNT		"400"
	SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"401"
	SOF_TKN_COMP_FORMAT			"402"
# Token retired with ABI 3.2, do not use for new capabilities
#	SOF_TKN_COMP_PRELOAD_COUNT		"403"
}

SectionVendorTokens."sof_ssp_tokens" {
	SOF_TKN_INTEL_SSP_CLKS_CONTROL		"500"
	SOF_TKN_INTEL_SSP_MCLK_ID		"501"
	SOF_TKN_INTEL_SSP_SAMPLE_BITS		"502"
	SOF_TKN_INTEL_SSP_FRAME_PULSE_WIDTH 	"503"
	SOF_TKN_INTEL_SSP_QUIRKS		"504"
	SOF_TKN_INTEL_SSP_TDM_PADDING_PER_SLOT  "505"
	SOF_TKN_INTEL_SSP_BCLK_DELAY		"506"
}

SectionVendorTokens."sof_dmic_tokens" {
	SOF_TKN_INTEL_DMIC_DRIVER_VERSION	"600"
	SOF_TKN_INTEL_DMIC_CLK_MIN		"601"
	SOF_TKN_INTEL_DMIC_CLK_MAX		"602"
	SOF_TKN_INTEL_DMIC_DUTY_MIN		"603"
	SOF_TKN_INTEL_DMIC_DUTY_MAX		"604"
	SOF_TKN_INTEL_DMIC_NUM_PDM_ACTIVE	"605"
	SOF_TKN_INTEL_DMIC_SAMPLE_RATE		"608"
	SOF_TKN_INTEL_DMIC_FIFO_WORD_LENGTH	"609"
	SOF_TKN_INTEL_DMIC_UNMUTE_RAMP_TIME_MS	"610"
}

SectionVendorTokens."sof_dmic_pdm_tokens" {
	SOF_TKN_INTEL_DMIC_PDM_CTRL_ID		"700"
	SOF_TKN_INTEL_DMIC_PDM_MIC_A_Enable	"701"
	SOF_TKN_INTEL_DMIC_PDM_MIC_B_Enable	"702"
	SOF_TKN_INTEL_DMIC_PDM_POLARITY_A	"703"
	SOF_TKN_INTEL_DMIC_PDM_POLARITY_B	"704"
	SOF_TKN_INTEL_DMIC_PDM_CLK_EDGE		"705"
	SOF_TKN_INTEL_DMIC_PDM_SKEW		"706"
}

SectionVendorTokens."sof_tone_tokens" {
	SOF_TKN_TONE_SAMPLE_RATE		"800"
}

SectionVendorTokens."sof_process_tokens" {
	SOF_TKN_PROCESS_TYPE			"900"
}

SectionVendorTokens."sof_sai_tokens" {
	SOF_TKN_IMX_SAI_MCLK_ID			"1000"
}

SectionVendorTokens."sof_esai_tokens" {
	SOF_TKN_IMX_ESAI_MCLK_ID		"1100"
}

SectionVendorTokens."sof_stream_tokens" {
	SOF_TKN_STREAM_PLAYBACK_COMPATIBLE_D0I3		"1200"
	SOF_TKN_STREAM_CAPTURE_COMPATIBLE_D0I3		"1201"
}

SectionVendorTokens."sof_led_tokens" {
	SOF_TKN_MUTE_LED_USE			"1300"
	SOF_TKN_MUTE_LED_DIRECTION		"1301"
}


# Include bxt DSP configuration
#
# Broxton differentiation for pipelines and components
#
















# Low Latency PCM Configuration
SectionVendorTuples."pipe_ll_schedule_plat_tokens" {
	tokens "sof_sched_tokens"

	tuples."word" {
		SOF_TKN_SCHED_MIPS	"50000"
		
	}
}

SectionData."pipe_ll_schedule_plat" {
	tuples "pipe_ll_schedule_plat_tokens"
}

# Media PCM Configuration
SectionVendorTuples."pipe_media_schedule_plat_tokens" {
	tokens "sof_sched_tokens"

	tuples."word" {
		SOF_TKN_SCHED_MIPS	"100000"
		
	}
}

SectionData."pipe_media_schedule_plat" {
	tuples "pipe_media_schedule_plat_tokens"
}

# Tone Signal Generator Configuration
SectionVendorTuples."pipe_tone_schedule_plat_tokens" {
	tokens "sof_sched_tokens"

	tuples."word" {
		SOF_TKN_SCHED_MIPS	"200000"
		
	}
}

SectionData."pipe_tone_schedule_plat" {
	tuples "pipe_tone_schedule_plat_tokens"
}

# DAI schedule Configuration - scheduled by IRQ
SectionVendorTuples."pipe_dai_schedule_plat_tokens" {
	tokens "sof_sched_tokens"

	tuples."word" {
		SOF_TKN_SCHED_MIPS	"5000"
		
	}
}

SectionData."pipe_dai_schedule_plat" {
	tuples "pipe_dai_schedule_plat_tokens"
}


# Define pipeline id for intel-generic-dmic.m4
# to generate dmic setting





#
# Topology for digital microphones array
#



# defined in machine driver



#
# Define the pipelines
#


# Passthrough capture pipeline using max channels defined by CHANNELS.

# Set 1000us deadline on core 0 with priority 0




























# Capture EQ Pipeline and PCM, 48 kHz
#
# Pipeline Endpoints for connection are :-
#
#  host PCM_C <-- B0 <-- Volume 0 <-- B1 <--EQ_IIR 0 <-- B2 <-- sink DAI0

# Include topology builder




































 



































#
# Controls
#

# Volume Mixer control with max value of 32
 
SectionControlMixer."Capture Volume" {

	# control belongs to this index group
	index "5"

	#Channel register and shift for Front Left/Right
	channel."FL" {
		reg "1"
		shift "0"
	}
	channel."FR" {
		reg "1"
		shift "1"
	}
	
	# control uses bespoke driver get/put/info ID
	ops."ctl" {
		info "volsw"
		#256 binds the mixer control to volume get/put handlers
		get "256"
		put "256"
	}

	#
	max "70"
	invert "false"
	#TLV 80 steps from -50dB to +20dB for 1dB
	tlv "vtlv_m50s1"
 
}



# Switch type Mixer Control with max value of 1
SectionVendorTuples."CONTROLMIXER5.5_tuples_w" {
	tokens "sof_led_tokens"
	tuples."word" {
		SOF_TKN_MUTE_LED_USE		"1"
		SOF_TKN_MUTE_LED_DIRECTION	"1"
	}
}
SectionData."CONTROLMIXER5.5_data_w" {
	tuples "CONTROLMIXER5.5_tuples_w"
}

SectionControlMixer."Capture Switch" {

	# control belongs to this index group
	index "5"

	#Channel register and shift for Front Left/Right
	channel."FL" {
		reg "2"
		shift "0"
	}
	channel."FR" {
		reg "2"
		shift "1"
	}
	
	# control uses bespoke driver get/put/info ID
	ops."ctl" {
		info "volsw"
		#259 binds the mixer control to switch get/put handlers
		get "259"
		put "259"
	}

	#max 1 indicates switch type control
	max "1"
	invert "false"
	
	data [
		"CONTROLMIXER5.5_data_w"
	]

}

# Volume Configuration
SectionVendorTuples."capture_pga_tokens" {
	tokens "sof_volume_tokens"

	tuples."word" {
		SOF_TKN_VOLUME_RAMP_STEP_TYPE	"0"
     		
		SOF_TKN_VOLUME_RAMP_STEP_MS		"250"
		
	}
}

SectionData."capture_pga_conf" {
	tuples "capture_pga_tokens"
}

# Use 50 Hz highpass response with +20 dB gain
# 50 Hz second order high-pass and +20 dB gain 18-Dec-2018
SectionData."EQIIR_HP50HZ20dB48K_priv" {
	       bytes "0x53,0x4f,0x46,0x00,0x00,0x00,0x00,0x00,
       0x58,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x58,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
       0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
       0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x63,0xf3,0x96,0xc0,
       0xc6,0x59,0x68,0x7f,0x6d,0x89,0xed,0x1f,
       0x27,0xed,0x24,0xc0,0x6d,0x89,0xed,0x1f,
       0xfc,0xff,0xff,0xff,0xd0,0x4f,0x00,0x00"

}


# EQ Bytes control with max value of 255
SectionControlBytes."EQIIR_C48" {

	# control belongs to this index group
	index "5"

	# control uses bespoke driver get/put/info ID for io ops
	ops."ctl" {
		info "bytes"
		#258 binds the mixer control to bytes get/put handlers
	}
	# control uses bespoke driver get/put/info ID for ext ops
	extops."extctl" {
		#258 binds the mixer control to bytes get/put handlers
		get "258"
		put "258"
	}

	base ""
	num_regs ""
	mask ""
	#
	max "304"
	
	access [
		tlv_write
		tlv_read
		tlv_callback
	]
	data [
		EQIIR_HP50HZ20dB48K_priv
	]
}

#
# Components and Buffers
#

# Host "Highpass Capture" PCM
# with 0 sink and 2 source periods
SectionVendorTuples."PCM6C_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"0"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."PCM6C_data_w_comp" {
	tuples "PCM6C_tuples_w_comp"
}
SectionWidget."PCM6C" {
	index "5"
	type "aif_out"
	no_pm "true"
	stream_name "Highpass Capture 6"
	data [
		"PCM6C_data_w_comp"
	]
}

# "Volume" has 2 source and 2 sink periods
SectionVendorTuples."PGA5.0_tuples_w" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."PGA5.0_data_w" {
	tuples "PGA5.0_tuples_w"
}
SectionVendorTuples."PGA5.0_tuples_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."PGA5.0_data_str" {
	tuples "PGA5.0_tuples_str"
}
SectionWidget."Dmic0" {
	index "5"
	type "pga"
	no_pm "true"
	data [
		"PGA5.0_data_w"
		"PGA5.0_data_str"
		"capture_pga_conf"
	]
	mixer [
		"Capture Volume"
		"Capture Switch"
		
	]

}

# "EQ 0" has 2 sink period and x source periods
SectionVendorTuples."EQIIR5.0_tuples_w" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."EQIIR5.0_data_w" {
	tuples "EQIIR5.0_tuples_w"
}
SectionVendorTuples."EQIIR5.0_tuples_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."EQIIR5.0_data_str" {
	tuples "EQIIR5.0_tuples_str"
}
SectionVendorTuples."EQIIR5.0_tuples_str_type" {
	tokens "sof_process_tokens"
	tuples."string" {
		SOF_TKN_PROCESS_TYPE	"EQIIR"
	}
}
SectionData."EQIIR5.0_data_str_type" {
	tuples "EQIIR5.0_tuples_str_type"
}
SectionWidget."EQIIR5.0" {
	index "5"
	type "effect"
	no_pm "true"
	data [
		"EQIIR5.0_data_w"
		"EQIIR5.0_data_str"
		"EQIIR5.0_data_str_type"
	]
	bytes [
		"EQIIR_C48"
		
	]
}

# Capture Buffers
SectionVendorTuples."BUF5.0_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"1536"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF5.0_data" {
	tuples "BUF5.0_tuples"
}
SectionWidget."BUF5.0" {
	index "5"
	type "buffer"
	no_pm "true"
	data [
		"BUF5.0_data"
	]
}

SectionVendorTuples."BUF5.1_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"1536"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF5.1_data" {
	tuples "BUF5.1_tuples"
}
SectionWidget."BUF5.1" {
	index "5"
	type "buffer"
	no_pm "true"
	data [
		"BUF5.1_data"
	]
}

SectionVendorTuples."BUF5.2_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"1536"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF5.2_data" {
	tuples "BUF5.2_tuples"
}
SectionWidget."BUF5.2" {
	index "5"
	type "buffer"
	no_pm "true"
	data [
		"BUF5.2_data"
	]
}

#
# Pipeline Graph
#
#  host PCM_C <-- B0 <-- Volume 0 <-- B1 <--EQ_IIR 0 <-- B2 <-- sink DAI0

SectionGraph."pipe-pass-capture-5" {
	index "5"

	lines [
		"PCM6C, , BUF5.0"
		"BUF5.0, , Dmic0"
		"Dmic0, , BUF5.1"
		"BUF5.1, , EQIIR5.0"
		"EQIIR5.0, , BUF5.2"
		
	]
}






#
# Pipeline Source and Sinks
#



#
# PCM Configuration
#

SectionPCMCapabilities."Highpass Capture 6" {

	formats "S32_LE,S24_LE,S16_LE"
	rate_min "48000"
	rate_max "48000"
	channels_min "4"
	channels_max "4"
	periods_min "2"
	periods_max "16"
	period_size_min	"192"
	period_size_max	"16384"
	buffer_size_min	"65536"
	buffer_size_max	"65536"
}





# Passthrough capture pipeline using max channels defined by CHANNELS.

# Schedule with 1000us deadline on core 0 with priority 0




























# Capture EQ Pipeline and PCM, 16 kHz
#
# Pipeline Endpoints for connection are :-
#
#  host PCM_C <-- B0 <-- Volume 0 <-- B1 <--EQ_IIR 0 <-- B2 <-- sink DAI0

# Include topology builder




































 
































#
# Controls
#

# Volume Mixer control with max value of 32
 
SectionControlMixer."Capture Volume" {

	# control belongs to this index group
	index "6"

	#Channel register and shift for Front Left/Right
	channel."FL" {
		reg "1"
		shift "0"
	}
	channel."FR" {
		reg "1"
		shift "1"
	}
	
	# control uses bespoke driver get/put/info ID
	ops."ctl" {
		info "volsw"
		#256 binds the mixer control to volume get/put handlers
		get "256"
		put "256"
	}

	#
	max "70"
	invert "false"
	#TLV 80 steps from -50dB to +20dB for 1dB
	tlv "vtlv_m50s1"
 
}

# Volume Configuration
SectionVendorTuples."capture_pga_tokens" {
	tokens "sof_volume_tokens"

	tuples."word" {
		SOF_TKN_VOLUME_RAMP_STEP_TYPE	"0"
     		
		SOF_TKN_VOLUME_RAMP_STEP_MS		"250"
		
	}
}

SectionData."capture_pga_conf" {
	tuples "capture_pga_tokens"
}

# Use 50 Hz highpass response with +20 dB gain
# 50 Hz second order high-pass and +20 dB gain 13-Aug-2019
SectionData."EQIIR_HP50HZ20dB16K_priv" {
	       bytes "0x53,0x4f,0x46,0x00,0x00,0x00,0x00,0x00,
       0x58,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x58,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
       0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
       0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
       0x00,0x00,0x00,0x00,0x57,0xb1,0xc0,0xc1,
       0xd2,0x13,0x39,0x7e,0x45,0x3b,0xa2,0x1f,
       0x76,0x89,0xbb,0xc0,0x45,0x3b,0xa2,0x1f,
       0xfc,0xff,0xff,0xff,0xd0,0x4f,0x00,0x00"

}


# EQ Bytes control with max value of 255
SectionControlBytes."EQIIR_C16" {

	# control belongs to this index group
	index "6"

	# control uses bespoke driver get/put/info ID for io ops
	ops."ctl" {
		info "bytes"
		#258 binds the mixer control to bytes get/put handlers
	}
	# control uses bespoke driver get/put/info ID for ext ops
	extops."extctl" {
		#258 binds the mixer control to bytes get/put handlers
		get "258"
		put "258"
	}

	base ""
	num_regs ""
	mask ""
	#
	max "304"
	
	access [
		tlv_write
		tlv_read
		tlv_callback
	]
	data [
		EQIIR_HP50HZ20dB16K_priv
	]
}

#
# Components and Buffers
#

# Host "Highpass Capture" PCM
# with 0 sink and 2 source periods
SectionVendorTuples."PCM7C_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"0"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."PCM7C_data_w_comp" {
	tuples "PCM7C_tuples_w_comp"
}
SectionWidget."PCM7C" {
	index "6"
	type "aif_out"
	no_pm "true"
	stream_name "Highpass Capture 7"
	data [
		"PCM7C_data_w_comp"
	]
}

# "Volume" has 2 source and 2 sink periods
SectionVendorTuples."PGA6.0_tuples_w" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."PGA6.0_data_w" {
	tuples "PGA6.0_tuples_w"
}
SectionVendorTuples."PGA6.0_tuples_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."PGA6.0_data_str" {
	tuples "PGA6.0_tuples_str"
}
SectionWidget."Dmic1" {
	index "6"
	type "pga"
	no_pm "true"
	data [
		"PGA6.0_data_w"
		"PGA6.0_data_str"
		"capture_pga_conf"
	]
	mixer [
		"Capture Volume"
		
	]

}

# "EQ 0" has 2 sink period and x source periods
SectionVendorTuples."EQIIR6.0_tuples_w" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."EQIIR6.0_data_w" {
	tuples "EQIIR6.0_tuples_w"
}
SectionVendorTuples."EQIIR6.0_tuples_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."EQIIR6.0_data_str" {
	tuples "EQIIR6.0_tuples_str"
}
SectionVendorTuples."EQIIR6.0_tuples_str_type" {
	tokens "sof_process_tokens"
	tuples."string" {
		SOF_TKN_PROCESS_TYPE	"EQIIR"
	}
}
SectionData."EQIIR6.0_data_str_type" {
	tuples "EQIIR6.0_tuples_str_type"
}
SectionWidget."EQIIR6.0" {
	index "6"
	type "effect"
	no_pm "true"
	data [
		"EQIIR6.0_data_w"
		"EQIIR6.0_data_str"
		"EQIIR6.0_data_str_type"
	]
	bytes [
		"EQIIR_C16"
		
	]
}

# Capture Buffers
SectionVendorTuples."BUF6.0_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"512"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF6.0_data" {
	tuples "BUF6.0_tuples"
}
SectionWidget."BUF6.0" {
	index "6"
	type "buffer"
	no_pm "true"
	data [
		"BUF6.0_data"
	]
}

SectionVendorTuples."BUF6.1_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"512"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF6.1_data" {
	tuples "BUF6.1_tuples"
}
SectionWidget."BUF6.1" {
	index "6"
	type "buffer"
	no_pm "true"
	data [
		"BUF6.1_data"
	]
}

SectionVendorTuples."BUF6.2_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"512"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF6.2_data" {
	tuples "BUF6.2_tuples"
}
SectionWidget."BUF6.2" {
	index "6"
	type "buffer"
	no_pm "true"
	data [
		"BUF6.2_data"
	]
}

#
# Pipeline Graph
#
#  host PCM_C <-- B0 <-- Volume 0 <-- B1 <--EQ_IIR 0 <-- B2 <-- sink DAI0

SectionGraph."pipe-pass-capture-6" {
	index "6"

	lines [
		"PCM7C, , BUF6.0"
		"BUF6.0, , Dmic1"
		"Dmic1, , BUF6.1"
		"BUF6.1, , EQIIR6.0"
		"EQIIR6.0, , BUF6.2"
		
	]
}




#
# Pipeline Source and Sinks
#



#
# PCM Configuration
#

SectionPCMCapabilities."Highpass Capture 7" {

	formats "S32_LE,S24_LE,S16_LE"
	rate_min "16000"
	rate_max "16000"
	channels_min "4"
	channels_max "4"
	periods_min "2"
	periods_max "16"
	period_size_min	"192"
	period_size_max	"16384"
	buffer_size_min	"65536"
	buffer_size_max	"65536"
}





#
# DAIs configuration
#


# capture DAI is DMIC 0 using 2 periods
# Buffers use s32le format, 1000us deadline on core 0 with priority 0























# DAI Capture connector

# Include topology builder




































 
























#
# DAI definitions
#
SectionVendorTuples."DMIC0.IN_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"0"
	}
}
SectionData."DMIC0.IN_data_w_comp" {
	tuples "DMIC0.IN_tuples_w_comp"
}
SectionVendorTuples."DMIC0.IN_tuples_w" {
	tokens "sof_dai_tokens"
	tuples."word" {
		SOF_TKN_DAI_INDEX	"0"
		SOF_TKN_DAI_DIRECTION	"1"
	}
}
SectionData."DMIC0.IN_data_w" {
	tuples "DMIC0.IN_tuples_w"
}
SectionVendorTuples."DMIC0.IN_tuples_str" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE	"DMIC"
	}
}
SectionData."DMIC0.IN_data_str" {
	tuples "DMIC0.IN_tuples_str"
}
SectionVendorTuples."DMIC0.IN_tuples_comp_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."DMIC0.IN_data_comp_str" {
	tuples "DMIC0.IN_tuples_comp_str"
}
SectionWidget."DMIC0.IN" {
	index "5"
	type "dai_out"
	stream_name "dmic01"
	no_pm "true"
	data [
		"DMIC0.IN_data_w"
		"DMIC0.IN_data_w_comp"
		"DMIC0.IN_data_str"
		"DMIC0.IN_data_comp_str"
	]
}

#
# DAI pipeline - always use 0 for DAIs
#
SectionVendorTuples."PIPELINE.5.DMIC0.IN_tuples" {
	tokens "sof_sched_tokens"
	tuples."word" {
		SOF_TKN_SCHED_PERIOD		"1000"
		SOF_TKN_SCHED_PRIORITY		"0"
		SOF_TKN_SCHED_CORE		"0"
		SOF_TKN_SCHED_FRAMES		"0"
		SOF_TKN_SCHED_TIME_DOMAIN	"48000"
	}
}
SectionData."PIPELINE.5.DMIC0.IN_data" {
	tuples "PIPELINE.5.DMIC0.IN_tuples"
}
SectionWidget."PIPELINE.5.DMIC0.IN" {
	index "5"
	type "scheduler"
	no_pm "true"
	stream_name "DMIC0.IN"
	data [
		"PIPELINE.5.DMIC0.IN_data"
		"pipe_dai_schedule_plat"
	]
}

#
# Graph connections to pipelines

SectionGraph."DMIC0" {
	index "5"

	lines [
		"BUF5.2, , DMIC0.IN"
		
	]
}






# capture DAI is DMIC 1 using 2 periods
# Buffers use s32le format, with 16 frame per 1000us on core 0 with priority 0























# DAI Capture connector

# Include topology builder




































 
























#
# DAI definitions
#
SectionVendorTuples."DMIC1.IN_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"0"
	}
}
SectionData."DMIC1.IN_data_w_comp" {
	tuples "DMIC1.IN_tuples_w_comp"
}
SectionVendorTuples."DMIC1.IN_tuples_w" {
	tokens "sof_dai_tokens"
	tuples."word" {
		SOF_TKN_DAI_INDEX	"1"
		SOF_TKN_DAI_DIRECTION	"1"
	}
}
SectionData."DMIC1.IN_data_w" {
	tuples "DMIC1.IN_tuples_w"
}
SectionVendorTuples."DMIC1.IN_tuples_str" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE	"DMIC"
	}
}
SectionData."DMIC1.IN_data_str" {
	tuples "DMIC1.IN_tuples_str"
}
SectionVendorTuples."DMIC1.IN_tuples_comp_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."DMIC1.IN_data_comp_str" {
	tuples "DMIC1.IN_tuples_comp_str"
}
SectionWidget."DMIC1.IN" {
	index "6"
	type "dai_out"
	stream_name "dmic16k"
	no_pm "true"
	data [
		"DMIC1.IN_data_w"
		"DMIC1.IN_data_w_comp"
		"DMIC1.IN_data_str"
		"DMIC1.IN_data_comp_str"
	]
}

#
# DAI pipeline - always use 0 for DAIs
#
SectionVendorTuples."PIPELINE.6.DMIC1.IN_tuples" {
	tokens "sof_sched_tokens"
	tuples."word" {
		SOF_TKN_SCHED_PERIOD		"1000"
		SOF_TKN_SCHED_PRIORITY		"0"
		SOF_TKN_SCHED_CORE		"0"
		SOF_TKN_SCHED_FRAMES		"0"
		SOF_TKN_SCHED_TIME_DOMAIN	"16000"
	}
}
SectionData."PIPELINE.6.DMIC1.IN_data" {
	tuples "PIPELINE.6.DMIC1.IN_tuples"
}
SectionWidget."PIPELINE.6.DMIC1.IN" {
	index "6"
	type "scheduler"
	no_pm "true"
	stream_name "DMIC1.IN"
	data [
		"PIPELINE.6.DMIC1.IN_data"
		"pipe_dai_schedule_plat"
	]
}

#
# Graph connections to pipelines

SectionGraph."DMIC1" {
	index "6"

	lines [
		"BUF6.2, , DMIC1.IN"
		
	]
}








SectionPCM."DMIC48kHz" {

	# used for binding to the PCM
	id "6"

	dai."DMIC48kHz 6" {
		id "6"
	}

	pcm."capture" {

		capabilities "Highpass Capture 6"
	}

}




SectionPCM."DMIC16kHz" {

	# used for binding to the PCM
	id "7"

	dai."DMIC16kHz 7" {
		id "7"
	}

	pcm."capture" {

		capabilities "Highpass Capture 7"
	}

}



#
# BE configurations - overrides config in ACPI if present
#

SectionHWConfig."DMIC0" {

	id		"6"

	}
SectionVendorTuples."DAICONFIG.DMIC0_dmic_tuples" {
	tokens "sof_dmic_tokens"
	tuples."word" {
		SOF_TKN_INTEL_DMIC_DRIVER_VERSION	"1"
		SOF_TKN_INTEL_DMIC_CLK_MIN		"500000"
		SOF_TKN_INTEL_DMIC_CLK_MAX		"4800000"
		SOF_TKN_INTEL_DMIC_DUTY_MIN		"40"
		SOF_TKN_INTEL_DMIC_DUTY_MAX		"60"
		SOF_TKN_INTEL_DMIC_SAMPLE_RATE		"48000"
		SOF_TKN_INTEL_DMIC_FIFO_WORD_LENGTH	"32"
		SOF_TKN_INTEL_DMIC_UNMUTE_RAMP_TIME_MS	"200"

		SOF_TKN_INTEL_DMIC_NUM_PDM_ACTIVE	"2"
	}
}
SectionVendorTuples."DAICONFIG.DMIC0_pdm_tuples" {
	tokens "sof_dmic_pdm_tokens"
	tuples."short.pdm0" {
		SOF_TKN_INTEL_DMIC_PDM_CTRL_ID		"0"
		SOF_TKN_INTEL_DMIC_PDM_MIC_A_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_MIC_B_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_A	"0"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_B	"0"
		SOF_TKN_INTEL_DMIC_PDM_CLK_EDGE	"0"
		SOF_TKN_INTEL_DMIC_PDM_SKEW		"0"
	}

	tuples."short.pdm1" {
		SOF_TKN_INTEL_DMIC_PDM_CTRL_ID		"1"
		SOF_TKN_INTEL_DMIC_PDM_MIC_A_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_MIC_B_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_A	"0"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_B	"0"
		SOF_TKN_INTEL_DMIC_PDM_CLK_EDGE	"0"
		SOF_TKN_INTEL_DMIC_PDM_SKEW		"0"
	}


}

SectionData."DAICONFIG.DMIC0_pdm_data" {
	tuples "DAICONFIG.DMIC0_pdm_tuples"
}
SectionData."DAICONFIG.DMIC0_data" {
	tuples "DAICONFIG.DMIC0_dmic_tuples"

}

SectionVendorTuples."DAICONFIG.DMIC0_tuples_common" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE		"DMIC"
	}
	tuples."word" {
		SOF_TKN_DAI_INDEX		"0"
	}
}
SectionData."DAICONFIG.DMIC0_data_common" {
	tuples "DAICONFIG.DMIC0_tuples_common"
}

SectionBE."dmic01" {
	id "6"
	index "0"
	default_hw_conf_id	"6"

	hw_configs [
		"DMIC0"
	]
	data [
		"DAICONFIG.DMIC0_data"
		"DAICONFIG.DMIC0_data_common"
		"DAICONFIG.DMIC0_pdm_data"
	]
}




SectionHWConfig."DMIC1" {

	id		"7"

	}
SectionVendorTuples."DAICONFIG.DMIC1_dmic_tuples" {
	tokens "sof_dmic_tokens"
	tuples."word" {
		SOF_TKN_INTEL_DMIC_DRIVER_VERSION	"1"
		SOF_TKN_INTEL_DMIC_CLK_MIN		"500000"
		SOF_TKN_INTEL_DMIC_CLK_MAX		"4800000"
		SOF_TKN_INTEL_DMIC_DUTY_MIN		"40"
		SOF_TKN_INTEL_DMIC_DUTY_MAX		"60"
		SOF_TKN_INTEL_DMIC_SAMPLE_RATE		"16000"
		SOF_TKN_INTEL_DMIC_FIFO_WORD_LENGTH	"32"
		SOF_TKN_INTEL_DMIC_UNMUTE_RAMP_TIME_MS	"400"

		SOF_TKN_INTEL_DMIC_NUM_PDM_ACTIVE	"2"
	}
}
SectionVendorTuples."DAICONFIG.DMIC1_pdm_tuples" {
	tokens "sof_dmic_pdm_tokens"
	tuples."short.pdm0" {
		SOF_TKN_INTEL_DMIC_PDM_CTRL_ID		"0"
		SOF_TKN_INTEL_DMIC_PDM_MIC_A_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_MIC_B_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_A	"0"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_B	"0"
		SOF_TKN_INTEL_DMIC_PDM_CLK_EDGE	"0"
		SOF_TKN_INTEL_DMIC_PDM_SKEW		"0"
	}

	tuples."short.pdm1" {
		SOF_TKN_INTEL_DMIC_PDM_CTRL_ID		"1"
		SOF_TKN_INTEL_DMIC_PDM_MIC_A_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_MIC_B_Enable	"1"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_A	"0"
		SOF_TKN_INTEL_DMIC_PDM_POLARITY_B	"0"
		SOF_TKN_INTEL_DMIC_PDM_CLK_EDGE	"0"
		SOF_TKN_INTEL_DMIC_PDM_SKEW		"0"
	}


}

SectionData."DAICONFIG.DMIC1_pdm_data" {
	tuples "DAICONFIG.DMIC1_pdm_tuples"
}
SectionData."DAICONFIG.DMIC1_data" {
	tuples "DAICONFIG.DMIC1_dmic_tuples"

}

SectionVendorTuples."DAICONFIG.DMIC1_tuples_common" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE		"DMIC"
	}
	tuples."word" {
		SOF_TKN_DAI_INDEX		"1"
	}
}
SectionData."DAICONFIG.DMIC1_data_common" {
	tuples "DAICONFIG.DMIC1_tuples_common"
}

SectionBE."dmic16k" {
	id "7"
	index "0"
	default_hw_conf_id	"7"

	hw_configs [
		"DMIC1"
	]
	data [
		"DAICONFIG.DMIC1_data"
		"DAICONFIG.DMIC1_data_common"
		"DAICONFIG.DMIC1_pdm_data"
	]
}







#
# Define the pipelines
#
# PCM1 ----> volume -----> iDisp1
# PCM2 ----> volume -----> iDisp2
# PCM3 ----> volume -----> iDisp3
#


# Low Latency playback pipeline 2 on PCM 1 using max 2 channels of s32le.
# Set 1000us deadline on core 0 with priority 0




























# Low Latency Passthrough with volume Pipeline and PCM
#
# Pipeline Endpoints for connection are :-
#
#  host PCM_P --> B0 --> Volume 0 --> B1 --> sink DAI0

# Include topology builder




































 




























#
# Controls
#
# Volume Mixer control with max value of 32
 
SectionControlMixer."2 Master Playback Volume" {

	# control belongs to this index group
	index "2"

	#Channel register and shift for Front Left/Right
	channel."FL" {
		reg "1"
		shift "0"
	}
	channel."FR" {
		reg "1"
		shift "1"
	}
	
	# control uses bespoke driver get/put/info ID
	ops."ctl" {
		info "volsw"
		#256 binds the mixer control to volume get/put handlers
		get "256"
		put "256"
	}

	#
	max "32"
	invert "false"
	#TLV 32 steps from -64dB to 0dB for 2dB
	tlv "vtlv_m64s2"
 
}

#
# Volume configuration
#

SectionVendorTuples."playback_pga_tokens" {
	tokens "sof_volume_tokens"

	tuples."word" {
		SOF_TKN_VOLUME_RAMP_STEP_TYPE	"0"
     		
		SOF_TKN_VOLUME_RAMP_STEP_MS		"250"
		
	}
}

SectionData."playback_pga_conf" {
	tuples "playback_pga_tokens"
}

#
# Components and Buffers
#

# Host "Passthrough Playback" PCM
# with 2 sink and 0 source periods
SectionVendorTuples."PCM1P_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"0"
	}
}
SectionData."PCM1P_data_w_comp" {
	tuples "PCM1P_tuples_w_comp"
}
SectionWidget."PCM1P" {
	index "2"
	type "aif_in"
	no_pm "true"
	stream_name "Passthrough Playback 1"
	data [
		"PCM1P_data_w_comp"
	]
}


# "Volume" has 2 source and x sink periods
SectionVendorTuples."PGA2.0_tuples_w" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."PGA2.0_data_w" {
	tuples "PGA2.0_tuples_w"
}
SectionVendorTuples."PGA2.0_tuples_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."PGA2.0_data_str" {
	tuples "PGA2.0_tuples_str"
}
SectionWidget."PGA2.0" {
	index "2"
	type "pga"
	no_pm "true"
	data [
		"PGA2.0_data_w"
		"PGA2.0_data_str"
		"playback_pga_conf"
	]
	mixer [
		"2 Master Playback Volume"
		
	]

}

# Playback Buffers
SectionVendorTuples."BUF2.0_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"768"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF2.0_data" {
	tuples "BUF2.0_tuples"
}
SectionWidget."BUF2.0" {
	index "2"
	type "buffer"
	no_pm "true"
	data [
		"BUF2.0_data"
	]
}
SectionVendorTuples."BUF2.1_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"768"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF2.1_data" {
	tuples "BUF2.1_tuples"
}
SectionWidget."BUF2.1" {
	index "2"
	type "buffer"
	no_pm "true"
	data [
		"BUF2.1_data"
	]
}

#
# Pipeline Graph
#
#  host PCM_P --> B0 --> Volume 0 --> B1 --> sink DAI0

SectionGraph."pipe-pass-vol-playback-2" {
	index "2"

	lines [
		"BUF2.0, , PCM1P"
		"PGA2.0, , BUF2.0"
		"BUF2.1, , PGA2.0"
		
	]
}

#
# Pipeline Source and Sinks
#




#
# PCM Configuration

#
SectionPCMCapabilities."Passthrough Playback 1" {

	formats "S32_LE,S24_LE,S16_LE"
	rate_min "48000"
	rate_max "48000"
	channels_min "2"
	channels_max "2"
	periods_min "2"
	periods_max "16"
	period_size_min	"192"
	period_size_max	"16384"
	buffer_size_min	"65536"
	buffer_size_max	"65536"
}






# Low Latency playback pipeline 3 on PCM 2 using max 2 channels of s32le.
# Set 1000us deadline on core 0 with priority 0




























# Low Latency Passthrough with volume Pipeline and PCM
#
# Pipeline Endpoints for connection are :-
#
#  host PCM_P --> B0 --> Volume 0 --> B1 --> sink DAI0

# Include topology builder




































 




























#
# Controls
#
# Volume Mixer control with max value of 32
 
SectionControlMixer."3 Master Playback Volume" {

	# control belongs to this index group
	index "3"

	#Channel register and shift for Front Left/Right
	channel."FL" {
		reg "1"
		shift "0"
	}
	channel."FR" {
		reg "1"
		shift "1"
	}
	
	# control uses bespoke driver get/put/info ID
	ops."ctl" {
		info "volsw"
		#256 binds the mixer control to volume get/put handlers
		get "256"
		put "256"
	}

	#
	max "32"
	invert "false"
	#TLV 32 steps from -64dB to 0dB for 2dB
	tlv "vtlv_m64s2"
 
}

#
# Volume configuration
#

SectionVendorTuples."playback_pga_tokens" {
	tokens "sof_volume_tokens"

	tuples."word" {
		SOF_TKN_VOLUME_RAMP_STEP_TYPE	"0"
     		
		SOF_TKN_VOLUME_RAMP_STEP_MS		"250"
		
	}
}

SectionData."playback_pga_conf" {
	tuples "playback_pga_tokens"
}

#
# Components and Buffers
#

# Host "Passthrough Playback" PCM
# with 2 sink and 0 source periods
SectionVendorTuples."PCM2P_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"0"
	}
}
SectionData."PCM2P_data_w_comp" {
	tuples "PCM2P_tuples_w_comp"
}
SectionWidget."PCM2P" {
	index "3"
	type "aif_in"
	no_pm "true"
	stream_name "Passthrough Playback 2"
	data [
		"PCM2P_data_w_comp"
	]
}


# "Volume" has 2 source and x sink periods
SectionVendorTuples."PGA3.0_tuples_w" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."PGA3.0_data_w" {
	tuples "PGA3.0_tuples_w"
}
SectionVendorTuples."PGA3.0_tuples_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."PGA3.0_data_str" {
	tuples "PGA3.0_tuples_str"
}
SectionWidget."PGA3.0" {
	index "3"
	type "pga"
	no_pm "true"
	data [
		"PGA3.0_data_w"
		"PGA3.0_data_str"
		"playback_pga_conf"
	]
	mixer [
		"3 Master Playback Volume"
		
	]

}

# Playback Buffers
SectionVendorTuples."BUF3.0_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"768"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF3.0_data" {
	tuples "BUF3.0_tuples"
}
SectionWidget."BUF3.0" {
	index "3"
	type "buffer"
	no_pm "true"
	data [
		"BUF3.0_data"
	]
}
SectionVendorTuples."BUF3.1_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"768"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF3.1_data" {
	tuples "BUF3.1_tuples"
}
SectionWidget."BUF3.1" {
	index "3"
	type "buffer"
	no_pm "true"
	data [
		"BUF3.1_data"
	]
}

#
# Pipeline Graph
#
#  host PCM_P --> B0 --> Volume 0 --> B1 --> sink DAI0

SectionGraph."pipe-pass-vol-playback-3" {
	index "3"

	lines [
		"BUF3.0, , PCM2P"
		"PGA3.0, , BUF3.0"
		"BUF3.1, , PGA3.0"
		
	]
}

#
# Pipeline Source and Sinks
#




#
# PCM Configuration

#
SectionPCMCapabilities."Passthrough Playback 2" {

	formats "S32_LE,S24_LE,S16_LE"
	rate_min "48000"
	rate_max "48000"
	channels_min "2"
	channels_max "2"
	periods_min "2"
	periods_max "16"
	period_size_min	"192"
	period_size_max	"16384"
	buffer_size_min	"65536"
	buffer_size_max	"65536"
}






# Low Latency playback pipeline 4 on PCM 3 using max 2 channels of s32le.
# Set 1000us deadline on core 0 with priority 0




























# Low Latency Passthrough with volume Pipeline and PCM
#
# Pipeline Endpoints for connection are :-
#
#  host PCM_P --> B0 --> Volume 0 --> B1 --> sink DAI0

# Include topology builder




































 




























#
# Controls
#
# Volume Mixer control with max value of 32
 
SectionControlMixer."4 Master Playback Volume" {

	# control belongs to this index group
	index "4"

	#Channel register and shift for Front Left/Right
	channel."FL" {
		reg "1"
		shift "0"
	}
	channel."FR" {
		reg "1"
		shift "1"
	}
	
	# control uses bespoke driver get/put/info ID
	ops."ctl" {
		info "volsw"
		#256 binds the mixer control to volume get/put handlers
		get "256"
		put "256"
	}

	#
	max "32"
	invert "false"
	#TLV 32 steps from -64dB to 0dB for 2dB
	tlv "vtlv_m64s2"
 
}

#
# Volume configuration
#

SectionVendorTuples."playback_pga_tokens" {
	tokens "sof_volume_tokens"

	tuples."word" {
		SOF_TKN_VOLUME_RAMP_STEP_TYPE	"0"
     		
		SOF_TKN_VOLUME_RAMP_STEP_MS		"250"
		
	}
}

SectionData."playback_pga_conf" {
	tuples "playback_pga_tokens"
}

#
# Components and Buffers
#

# Host "Passthrough Playback" PCM
# with 2 sink and 0 source periods
SectionVendorTuples."PCM3P_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"0"
	}
}
SectionData."PCM3P_data_w_comp" {
	tuples "PCM3P_tuples_w_comp"
}
SectionWidget."PCM3P" {
	index "4"
	type "aif_in"
	no_pm "true"
	stream_name "Passthrough Playback 3"
	data [
		"PCM3P_data_w_comp"
	]
}


# "Volume" has 2 source and x sink periods
SectionVendorTuples."PGA4.0_tuples_w" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"2"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."PGA4.0_data_w" {
	tuples "PGA4.0_tuples_w"
}
SectionVendorTuples."PGA4.0_tuples_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."PGA4.0_data_str" {
	tuples "PGA4.0_tuples_str"
}
SectionWidget."PGA4.0" {
	index "4"
	type "pga"
	no_pm "true"
	data [
		"PGA4.0_data_w"
		"PGA4.0_data_str"
		"playback_pga_conf"
	]
	mixer [
		"4 Master Playback Volume"
		
	]

}

# Playback Buffers
SectionVendorTuples."BUF4.0_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"768"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF4.0_data" {
	tuples "BUF4.0_tuples"
}
SectionWidget."BUF4.0" {
	index "4"
	type "buffer"
	no_pm "true"
	data [
		"BUF4.0_data"
	]
}
SectionVendorTuples."BUF4.1_tuples" {
	tokens "sof_buffer_tokens"
	tuples."word" {
		SOF_TKN_BUF_SIZE	"768"
		SOF_TKN_BUF_CAPS	"  113"
	}
}
SectionData."BUF4.1_data" {
	tuples "BUF4.1_tuples"
}
SectionWidget."BUF4.1" {
	index "4"
	type "buffer"
	no_pm "true"
	data [
		"BUF4.1_data"
	]
}

#
# Pipeline Graph
#
#  host PCM_P --> B0 --> Volume 0 --> B1 --> sink DAI0

SectionGraph."pipe-pass-vol-playback-4" {
	index "4"

	lines [
		"BUF4.0, , PCM3P"
		"PGA4.0, , BUF4.0"
		"BUF4.1, , PGA4.0"
		
	]
}

#
# Pipeline Source and Sinks
#




#
# PCM Configuration

#
SectionPCMCapabilities."Passthrough Playback 3" {

	formats "S32_LE,S24_LE,S16_LE"
	rate_min "48000"
	rate_max "48000"
	channels_min "2"
	channels_max "2"
	periods_min "2"
	periods_max "16"
	period_size_min	"192"
	period_size_max	"16384"
	buffer_size_min	"65536"
	buffer_size_max	"65536"
}






#
# DAIs configuration
#


# playback DAI is iDisp1 using 2 periods
# Buffers use s32le format, 1000us deadline on core 0 with priority 0























# DAI Playback connector

# Include topology builder




































 
























#
# DAI definitions
#
SectionVendorTuples."HDA0.OUT_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"0"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."HDA0.OUT_data_w_comp" {
	tuples "HDA0.OUT_tuples_w_comp"
}
SectionVendorTuples."HDA0.OUT_tuples_w" {
	tokens "sof_dai_tokens"
	tuples."word" {
		SOF_TKN_DAI_INDEX	"0"
		SOF_TKN_DAI_DIRECTION	"0"
	}
}
SectionData."HDA0.OUT_data_w" {
	tuples "HDA0.OUT_tuples_w"
}
SectionVendorTuples."HDA0.OUT_tuples_str" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE	"HDA"
	}
}
SectionData."HDA0.OUT_data_str" {
	tuples "HDA0.OUT_tuples_str"
}
SectionVendorTuples."HDA0.OUT_tuples_comp_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."HDA0.OUT_data_comp_str" {
	tuples "HDA0.OUT_tuples_comp_str"
}
SectionWidget."HDA0.OUT" {
	index "2"
	type "dai_in"
	stream_name "iDisp1"
	no_pm "true"
	data [
		"HDA0.OUT_data_w"
		"HDA0.OUT_data_w_comp"
		"HDA0.OUT_data_str"
		"HDA0.OUT_data_comp_str"
	]
}

#
# DAI pipeline - always use 0 for DAIs
#
SectionVendorTuples."PIPELINE.2.HDA0.OUT_tuples" {
	tokens "sof_sched_tokens"
	tuples."word" {
		SOF_TKN_SCHED_PERIOD		"1000"
		SOF_TKN_SCHED_PRIORITY		"0"
		SOF_TKN_SCHED_CORE		"0"
		SOF_TKN_SCHED_FRAMES		"0"
		SOF_TKN_SCHED_TIME_DOMAIN	"1"
	}
}
SectionData."PIPELINE.2.HDA0.OUT_data" {
	tuples "PIPELINE.2.HDA0.OUT_tuples"
}
SectionWidget."PIPELINE.2.HDA0.OUT" {
	index "2"
	type "scheduler"
	no_pm "true"
	stream_name "HDA0.OUT"
	data [
		"PIPELINE.2.HDA0.OUT_data"
		"pipe_dai_schedule_plat"
	]
}

#
# Graph connections to pipelines

SectionGraph."HDA0" {
	index "2"

	lines [
		"HDA0.OUT, , BUF2.1"
		
	]
}






# playback DAI is iDisp2 using 2 periods
# Buffers use s32le format, 1000us deadline on core 0 with priority 0























# DAI Playback connector

# Include topology builder




































 
























#
# DAI definitions
#
SectionVendorTuples."HDA1.OUT_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"0"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."HDA1.OUT_data_w_comp" {
	tuples "HDA1.OUT_tuples_w_comp"
}
SectionVendorTuples."HDA1.OUT_tuples_w" {
	tokens "sof_dai_tokens"
	tuples."word" {
		SOF_TKN_DAI_INDEX	"1"
		SOF_TKN_DAI_DIRECTION	"0"
	}
}
SectionData."HDA1.OUT_data_w" {
	tuples "HDA1.OUT_tuples_w"
}
SectionVendorTuples."HDA1.OUT_tuples_str" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE	"HDA"
	}
}
SectionData."HDA1.OUT_data_str" {
	tuples "HDA1.OUT_tuples_str"
}
SectionVendorTuples."HDA1.OUT_tuples_comp_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."HDA1.OUT_data_comp_str" {
	tuples "HDA1.OUT_tuples_comp_str"
}
SectionWidget."HDA1.OUT" {
	index "3"
	type "dai_in"
	stream_name "iDisp2"
	no_pm "true"
	data [
		"HDA1.OUT_data_w"
		"HDA1.OUT_data_w_comp"
		"HDA1.OUT_data_str"
		"HDA1.OUT_data_comp_str"
	]
}

#
# DAI pipeline - always use 0 for DAIs
#
SectionVendorTuples."PIPELINE.3.HDA1.OUT_tuples" {
	tokens "sof_sched_tokens"
	tuples."word" {
		SOF_TKN_SCHED_PERIOD		"1000"
		SOF_TKN_SCHED_PRIORITY		"0"
		SOF_TKN_SCHED_CORE		"0"
		SOF_TKN_SCHED_FRAMES		"0"
		SOF_TKN_SCHED_TIME_DOMAIN	"1"
	}
}
SectionData."PIPELINE.3.HDA1.OUT_data" {
	tuples "PIPELINE.3.HDA1.OUT_tuples"
}
SectionWidget."PIPELINE.3.HDA1.OUT" {
	index "3"
	type "scheduler"
	no_pm "true"
	stream_name "HDA1.OUT"
	data [
		"PIPELINE.3.HDA1.OUT_data"
		"pipe_dai_schedule_plat"
	]
}

#
# Graph connections to pipelines

SectionGraph."HDA1" {
	index "3"

	lines [
		"HDA1.OUT, , BUF3.1"
		
	]
}






# playback DAI is iDisp3 using 2 periods
# Buffers use s32le format, 1000us deadline on core 0 with priority 0























# DAI Playback connector

# Include topology builder




































 
























#
# DAI definitions
#
SectionVendorTuples."HDA2.OUT_tuples_w_comp" {
	tokens "sof_comp_tokens"
	tuples."word" {
		SOF_TKN_COMP_PERIOD_SINK_COUNT		"0"
		SOF_TKN_COMP_PERIOD_SOURCE_COUNT	"2"
	}
}
SectionData."HDA2.OUT_data_w_comp" {
	tuples "HDA2.OUT_tuples_w_comp"
}
SectionVendorTuples."HDA2.OUT_tuples_w" {
	tokens "sof_dai_tokens"
	tuples."word" {
		SOF_TKN_DAI_INDEX	"2"
		SOF_TKN_DAI_DIRECTION	"0"
	}
}
SectionData."HDA2.OUT_data_w" {
	tuples "HDA2.OUT_tuples_w"
}
SectionVendorTuples."HDA2.OUT_tuples_str" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE	"HDA"
	}
}
SectionData."HDA2.OUT_data_str" {
	tuples "HDA2.OUT_tuples_str"
}
SectionVendorTuples."HDA2.OUT_tuples_comp_str" {
	tokens "sof_comp_tokens"
	tuples."string" {
		SOF_TKN_COMP_FORMAT	"s32le"
	}
}
SectionData."HDA2.OUT_data_comp_str" {
	tuples "HDA2.OUT_tuples_comp_str"
}
SectionWidget."HDA2.OUT" {
	index "4"
	type "dai_in"
	stream_name "iDisp3"
	no_pm "true"
	data [
		"HDA2.OUT_data_w"
		"HDA2.OUT_data_w_comp"
		"HDA2.OUT_data_str"
		"HDA2.OUT_data_comp_str"
	]
}

#
# DAI pipeline - always use 0 for DAIs
#
SectionVendorTuples."PIPELINE.4.HDA2.OUT_tuples" {
	tokens "sof_sched_tokens"
	tuples."word" {
		SOF_TKN_SCHED_PERIOD		"1000"
		SOF_TKN_SCHED_PRIORITY		"0"
		SOF_TKN_SCHED_CORE		"0"
		SOF_TKN_SCHED_FRAMES		"0"
		SOF_TKN_SCHED_TIME_DOMAIN	"1"
	}
}
SectionData."PIPELINE.4.HDA2.OUT_data" {
	tuples "PIPELINE.4.HDA2.OUT_tuples"
}
SectionWidget."PIPELINE.4.HDA2.OUT" {
	index "4"
	type "scheduler"
	no_pm "true"
	stream_name "HDA2.OUT"
	data [
		"PIPELINE.4.HDA2.OUT_data"
		"pipe_dai_schedule_plat"
	]
}

#
# Graph connections to pipelines

SectionGraph."HDA2" {
	index "4"

	lines [
		"HDA2.OUT, , BUF4.1"
		
	]
}






# PCM Low Latency, id 0
SectionPCM."HDMI1" {

	# used for binding to the PCM
	id "1"

	dai."HDMI1 1" {
		id "1"
	}

	pcm."playback" {

		capabilities "Passthrough Playback 1"
	}
}

SectionPCM."HDMI2" {

	# used for binding to the PCM
	id "2"

	dai."HDMI2 2" {
		id "2"
	}

	pcm."playback" {

		capabilities "Passthrough Playback 2"
	}
}

SectionPCM."HDMI3" {

	# used for binding to the PCM
	id "3"

	dai."HDMI3 3" {
		id "3"
	}

	pcm."playback" {

		capabilities "Passthrough Playback 3"
	}
}


#
# BE configurations - overrides config in ACPI if present
#

# 3 HDMI/DP outputs (ID: 1,2,3)
SectionHWConfig."HDA0" {

	id		"1"

	}

SectionVendorTuples."DAICONFIG.HDA0_tuples_common" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE		"HDA"
	}
	tuples."word" {
		SOF_TKN_DAI_INDEX		"0"
	}
}
SectionData."DAICONFIG.HDA0_data_common" {
	tuples "DAICONFIG.HDA0_tuples_common"
}

SectionBE."iDisp1" {
	id "1"
	index "0"
	default_hw_conf_id	"1"

	hw_configs [
		"HDA0"
	]
	data [
		
		"DAICONFIG.HDA0_data_common"

	]
}



SectionHWConfig."HDA1" {

	id		"2"

	}

SectionVendorTuples."DAICONFIG.HDA1_tuples_common" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE		"HDA"
	}
	tuples."word" {
		SOF_TKN_DAI_INDEX		"1"
	}
}
SectionData."DAICONFIG.HDA1_data_common" {
	tuples "DAICONFIG.HDA1_tuples_common"
}

SectionBE."iDisp2" {
	id "2"
	index "0"
	default_hw_conf_id	"2"

	hw_configs [
		"HDA1"
	]
	data [
		
		"DAICONFIG.HDA1_data_common"

	]
}



SectionHWConfig."HDA2" {

	id		"3"

	}

SectionVendorTuples."DAICONFIG.HDA2_tuples_common" {
	tokens "sof_dai_tokens"
	tuples."string" {
		SOF_TKN_DAI_TYPE		"HDA"
	}
	tuples."word" {
		SOF_TKN_DAI_INDEX		"2"
	}
}
SectionData."DAICONFIG.HDA2_data_common" {
	tuples "DAICONFIG.HDA2_tuples_common"
}

SectionBE."iDisp3" {
	id "3"
	index "0"
	default_hw_conf_id	"3"

	hw_configs [
		"HDA2"
	]
	data [
		
		"DAICONFIG.HDA2_data_common"

	]
}




SectionWidget."iDisp1_out" {
       index "2"
       type "output"
       no_pm "true"
}
SectionGraph."HDA" {
       index "2"

       lines [
               "iDisp1_out, , HDA0.OUT"
       ]
}
SectionWidget."iDisp2_out" {
       index "3"
       type "output"
       no_pm "true"
}
SectionGraph."HDA" {
       index "3"

       lines [
               "iDisp2_out, , HDA1.OUT"
       ]
}
SectionWidget."iDisp3_out" {
       index "4"
       type "output"
       no_pm "true"
}
SectionGraph."HDA" {
       index "4"

       lines [
               "iDisp3_out, , HDA2.OUT"
       ]
}

SectionWidget."iDisp3 Tx" {
       index "0"
       type "out_drv"
       no_pm "true"
}
SectionWidget."iDisp2 Tx" {
       index "1"
       type "out_drv"
       no_pm "true"
}
SectionWidget."iDisp1 Tx" {
       index "2"
       type "out_drv"
       no_pm "true"
}
